/**
 * BNF grammar for Regular Expressions.
 *
 * Based on RegExp grammar from ECMAScript:
 * http://www.ecma-international.org/ecma-262/7.0/#sec-patterns
 *
 * Parser generated by Syntax tool (npm: syntax-cli)
 *
 * Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 *
 * MIT Style License.
 */

// --------------------------------------------
// 1. Lexical grammar.

%lex

CHAR                    [^*?+\[\(\)]
ESC                     \\
U                       [0-9a-fA-F]

/**
 * Lexer state for character class.
 *
 * Some meta symbols inside a character class are treated as simple
 * symbols, so we return different token types for them.
 *
 * E.g. `(` yields L_PAREN token by default, however in a character
 * class it's  a simple symbol:
 *
 *   '('          return 'L_PAREN'
 *   <class>'('   return 'CHAR'
 *
 * This allows making BNF grammar simpler with less productions, and states.
 */
%s class

%%

<class>{ESC}'-'         return 'ESC_CHAR'
<class>'-'              return 'DASH'
<class>'/'              return 'CHAR'

<class>'{'              return 'CHAR'

'{'\d+'}'               return 'RANGE_EXACT'
'{'\d+',}'              return 'RANGE_OPEN'
'{'\d+','\d+'}'         return 'RANGE_CLOSED'

{ESC}'b'                return 'ESC_b'
{ESC}'B'                return 'ESC_B'

{ESC}'c'[a-zA-Z]        return 'CTRL_CH'

{ESC}'0'\d{1,2}         return 'OCT_CODE'
{ESC}'0'                return 'DEC_CODE'
{ESC}\d{1,3}            return 'DEC_CODE'

{ESC}'u'{U}{4}          return 'U_CODE'
{ESC}'u{'{U}{1,}'}'     return 'U_CODE'

{ESC}'x'{U}{2}          return 'HEX_CODE'

{ESC}[tnrdDsSwWvf]      return 'META_CHAR'

{ESC}'/'                return 'ESC_CHAR'

{ESC}{CHAR}             return 'ESC_CHAR'
{ESC}[*?+\[]            return 'ESC_CHAR'

<class>'('              return 'CHAR'
<class>')'              return 'CHAR'

'(?='                   return 'POS_LA_ASSERT'
'(?!'                   return 'NEG_LA_ASSERT'

'(?:'                   return 'NON_CAPTURE_GROUP'

'('                     return 'L_PAREN'
')'                     return 'R_PAREN'

<class>[*?+[^$]         return 'CHAR'
<class>{ESC}']'         return 'ESC_CHAR'

<class>']'              { this.popState(); return 'R_BRACKET' }

'^'                     return 'BOS'
'$'                     return 'EOS'

'*'                     return 'STAR'
'?'                     return 'Q_MARK'
'+'                     return 'PLUS'

'|'                     return 'BAR'

'.'                     return 'ANY'

'/'                     return 'SLASH'

{CHAR}                  return 'CHAR'

'[^'                    { this.pushState('class'); return 'NEG_CLASS' }
'['                     { this.pushState('class'); return 'L_BRACKET' }

/lex

// --------------------------------------------
// 2. Syntactic grammar.

%{

/**
 * Tracks capturing groups.
 */
let capturingGroupsCount = 0;

yyparse.onParseBegin = () => {
  capturingGroupsCount = 0;
};

/**
 * Extracts ranges from the range string.
 */
function getRange(text) {
  return text.match(/\d+/g).map(Number);
}

/**
 * Creates a character node.
 */
function Char(value, kind, loc) {
  let symbol;

  switch (kind) {
    case 'decimal': {
      const code = Number(value.slice(1));
      symbol = String.fromCodePoint(code);
      break;
    }
    case 'oct': {
      const code = parseInt(value.slice(1), 8);
      symbol = String.fromCodePoint(code);
      break;
    }
    case 'hex':
    case 'unicode': {
      const hex = value.slice(2).replace('{', '');
      const code = parseInt(hex, 16);
      symbol = String.fromCodePoint(code);
      break;
    }
  }

  return Node({
    type: 'Char',
    value,
    kind,
    symbol,
  }, loc);
}

/**
 * Valid flags per current ECMAScript spec and
 * stage 3+ proposals.
 */
const validFlags = 'gimsuy';

/**
 * Checks the flags are valid, and that
 * we don't duplicate flags.
 */
function checkFlags(flags) {
  const seen = new Set();

  for (const flag of flags) {
    if (seen.has(flag) || !validFlags.includes(flag)) {
      throw new SyntaxError(`Invalid flags: ${flags}`);
    }
    seen.add(flag);
  }

  return flags.split('').sort().join('');
}

/**
 * Creates an AST node with a location.
 *
 * NOTE: The `shouldCaptureLocations` meta variable is defined by Syntax tool.
 */
function Node(node, loc) {
  if (shouldCaptureLocations) {
    node.loc = {
      start: loc.startOffset,
      end: loc.endOffset,
    };
  }
  return node;
}

/**
 * Creates location node.
 */
function loc(start, end) {
  if (!shouldCaptureLocations) {
    return null;
  }

  return {
    startOffset: start.startOffset,
    endOffset: end.endOffset,
  };
}

%}

%%

RegExp
  : SLASH Pattern SLASH OptFlags
    {
      $$ = Node({
        type: 'RegExp',
        body: $2,
        flags: checkFlags($4),
      }, loc(@1, @4 || @3))
    }
  ;

OptFlags
  : Flags
  | /* empty */ { $$ = '' }
  ;

Flags
  : CHAR
  | Flags CHAR { $$ = $1 + $2 }
  ;

Pattern
  : Disjunction
  ;

Disjunction
  : Alternative

  | Disjunction BAR Alternative
    {
      $$ = Node({
        type: 'Disjunction',
        left: $1,
        right: $3,
      }, @$)
    }
  ;

Alternative
  : AlternativeEntries
    {
      if ($1.length === 0) {
        $$ = null;
        return;
      }

      if ($1.length === 1) {
        $$ = Node($1[0], @$);
      } else {
        $$ = Node({
          type: 'Alternative',
          expressions: $1,
        }, @$)
      }
    }
  ;

AlternativeEntries
  : /* empty */
    { $$ = [] }

  | AlternativeEntries Term
    { $$ = $1; $1.push($2) }
  ;

Term
  : Assertion
    { $$ = Node(Object.assign({type: 'Assertion'}, $1), @$) }

  | Atom OptQuantifier
    {
      $$ = $1;

      if ($2) {
        $$ = Node({
          type: 'Repetition',
          expression: $1,
          quantifier: $2,
        }, @$)
      }
    }
  ;

Assertion
  : BOS       { $$ = { kind: '^' } }
  | EOS       { $$ = { kind: '$' } }
  | ESC_b     { $$ = { kind: '\\b' } }
  | ESC_B     { $$ = { kind: '\\B' } }

  | POS_LA_ASSERT Disjunction R_PAREN
    {
      $$ = {
        kind: 'Lookahead',
        assertion: $2,
      }
    }

  | NEG_LA_ASSERT Disjunction R_PAREN
    {
      $$ = {
        kind: 'Lookahead',
        negative: true,
        assertion: $2,
      }
    }
  ;

Atom
  : SourceCharacter
  | CharacterClass
  | Group
  ;

SourceCharacter
  : CHAR
    { $$ = Char($1, 'simple', @$) }

  | ESC_CHAR
    { $$ = Char($1.slice(1), 'simple', @$); $$.escaped = true; }

  | U_CODE
    { $$ = Char($1, 'unicode', @$) }

  | CTRL_CH
    { $$ = Char($1, 'control', @$) }

  | HEX_CODE
    { $$ = Char($1, 'hex', @$) }

  | OCT_CODE
    { $$ = Char($1, 'oct', @$) }

  | DEC_CODE
    {
      const reference = Number($1.slice(1));

      if (reference > 0 && reference <= capturingGroupsCount) {
        $$ = Node({
          type: 'Backreference',
          reference,
        }, @$);
        return;
      }

      $$ = Char($1, 'decimal', @$);
    }

    | META_CHAR
      { $$ = Char($1, 'meta', @$) }

    | ANY
      { $$ = Char($1, 'meta', @$) }
  ;

OptQuantifier
  : Quantifier
  | /* empty */
  ;

Quantifier
  : QuantifierPrefix
  | QuantifierPrefix Q_MARK
    {
      $1.greedy = false;
      $$ = $1;
    }
  ;

QuantifierPrefix
  : STAR
    {
      $$ = Node({
        type: 'Quantifier',
        kind: $1,
        greedy: true,
      }, @$)
    }

  | PLUS
    {
      $$ = Node({
        type: 'Quantifier',
        kind: $1,
        greedy: true,
      }, @$)
    }

  | Q_MARK
    {
      $$ = Node({
        type: 'Quantifier',
        kind: $1,
        greedy: true,
      }, @$)
    }

  | RANGE_EXACT
    {
      const range = getRange($1);
      $$ = Node({
        type: 'Quantifier',
        kind: 'Range',
        from: range[0],
        to: range[0],
        greedy: true,
      }, @$)
    }

  | RANGE_OPEN
    {
      $$ = Node({
        type: 'Quantifier',
        kind: 'Range',
        from: getRange($1)[0],
        greedy: true,
      }, @$)
    }

  | RANGE_CLOSED
    {
      const range = getRange($1);
      $$ = Node({
        type: 'Quantifier',
        kind: 'Range',
        from: range[0],
        to: range[1],
        greedy: true,
      }, @$)
    }
  ;

Group
  : CapturingGroup
  | NonCapturingGroup
  ;

CapturingGroup
  : L_PAREN Disjunction R_PAREN
    {
      capturingGroupsCount++;
      $$ = Node({
        type: 'Group',
        capturing: true,
        expression: $2,
      }, @$)
    }
  ;

NonCapturingGroup
  : NON_CAPTURE_GROUP Disjunction R_PAREN
    {
      $$ = Node({
        type: 'Group',
        capturing: false,
        expression: $2,
      }, @$)
    }
  ;

CharacterClass
  : NEG_CLASS ClassRanges R_BRACKET
    {
      $$ = Node({
        type: 'CharacterClass',
        negative: true,
        expressions: $2,
      }, @$)
    }
  | L_BRACKET ClassRanges R_BRACKET
    {
      $$ = Node({
        type: 'CharacterClass',
        expressions: $2,
      }, @$)
    }
  ;

ClassRanges
  : /* empty */
  | NonemptyClassRanges
  ;

NonemptyClassRanges
  : ClassAtom
    { $$ = [$1] }

  | ClassAtom NonemptyClassRangesNoDash
    { $$ = [$1].concat($2) }

  | ClassAtom DASH ClassAtom ClassRanges
    {
      $$ = [
        Node({
          type: 'ClassRange',
          from: $1,
          to: $3,
        }, loc(@1, @3))
      ];

      if ($4) {
        $$ = $$.concat($4);
      }
    }
  ;

NonemptyClassRangesNoDash
  : ClassAtom
  | ClassAtomNoDash NonemptyClassRangesNoDash
    { $$ = [$1].concat($2) }

  | ClassAtomNoDash DASH ClassAtom ClassRanges
    {
      $$ = [
        Node({
          type: 'ClassRange',
          from: $1,
          to: $3,
        }, loc(@1, @3)),
      ];

      if ($4) {
        $$ = $$.concat($4);
      }
    }
  ;

ClassAtom
  : DASH
    { $$ = Char($1, 'simple', @$) }

  | ClassAtomNoDash
  ;

ClassAtomNoDash
  : SourceCharacter

  | ESC_b
    { $$ = Char($1, 'meta', @$) }
  ;
